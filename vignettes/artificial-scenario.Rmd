---
title: "Detecting-frontiers-in-artificial-scenario"
author: "Simon Carrignon"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Detecting-frontiers-in-artificial-scenario}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(devtools)
devtools::load_all(".")
library(sf)
```

We first create a fake spatial area made of simple geometric form:

```{r}



# prepare "circle data"
radius = 1
resolution=200
theta = seq(0, 2 * pi, length = resolution) # how finely tune is our ci

xcoords = radius * cos(theta) + 0
ycoords = radius * sin(theta) + 0

circle_points=cbind.data.frame(xcoords,ycoords,crs="4326")
circle.sf=st_as_sf(circle_points,coords=1:2)
circle.sf=st_cast(st_combine(circle.sf),"POLYGON")
plot(circle.sf,col=adjustcolor("pink",.2))

```

We have a perfectly circular island, that we will now split in equally sized regions

```{r}

protogrid=st_make_grid(circle.sf)
regions=st_intersection(circle.sf,protogrid)
plot(regions)
```
We populate our space with "people" (which are only the total number of measurement possible on each region). As in most social phenomena population are exponentially distributed we here have population size that are log normally distributed with E(log(Y))=5 

```{r}
logmean=10
logsd=2
regions=st_bind_cols(pop=round(exp(rnorm(n=length(regions),mean=log(logmean),sd=log(logsd)))),regions)

plot(regions)
```

We will then introduce a  binomial process whos probability decrease given the distance to it's origin points. If "pop" are households and `origin` the origination point of new cultural behavior, then `distrib` will show how many houselod adopted this specific behavior. If they are individuals and `origin` is the origination point of a sicknes, it will represent the number of people that get aftected....

To simplify the definition of origin it's simply the bottom of the circle:
```{r}

origin=st_as_sf(cbind.data.frame(0,-1),coords=1:2,crs=st_crs(regions))
distances=st_distance(regions,origin)
prob_adoption=1-distances/max(distances)
plot(cbind(regions,distances)[,"distances"])
regions$distrib=rbinom(n=nrow(regions),size=regions$pop,prob=prob_adoption)
plot(regions[,"distrib"])
```

First let see how well the ICAR regression can find the original probabilities of adoption/infection:

```{r}
frontier_model <- frontier_detect( data = regions, y = "distrib", n.trials = "pop")

plot(prob_adoption,frontier_model$fittedvalues[,1],xlab="real value",ylab="ICAR estimation")
```

From this example, and in all logic, there is not frontier:

```{r}
summary(frontier_model)
```

```{r}

logmean=500
logsd=5
regions$pop=round(exp(rnorm(n=nrow(regions),mean=log(logmean),sd=log(logsd))))
regions$distrib=rbinom(n=nrow(regions),size=regions$pop,prob=prob_adoption)
regions$prop=regions$distrib/regions$pop

plot(regions[,"prop"])
frontier_model <- frontier_detect( data = regions, y = "distrib", n.trials = "pop")

plot(prob_adoption,frontier_model$fittedvalues[,1],xlab="real value",ylab="ICAR estimation")
plot(regions[,"prop"],reset=F)
plot(frontier_as_sf(frontier_model),add=T,col="green",lwd=2)

```

Lets add a area, in the right part of the circle where the likelihood of adopting the new trait is dived by 10. We will simply use a point and a buffer around it to select region of less adoption.

```{r}
plot(st_geometry(regions),reset=F)
refractaire=st_buffer(st_as_sf(cbind.data.frame(0.6,.2),coords=1:2,crs=st_crs(regions)),.45)
plot(refractaire,add=T)
plot(regions[unlist(st_contains(refractaire,regions)),],add=T,col="red")
prob_adoption[st_contains(refractaire,regions)[[1]]]=prob_adoption[st_contains(refractaire,regions)[[1]]]/10
regions$distrib=rbinom(n=nrow(regions),size=regions$pop,prob=prob_adoption)
regions$prop=regions$distrib/regions$pop
plot(regions[,"prop"])
frontier_model <- frontier_detect( data = regions, y = "distrib", n.trials = "pop")

plot(prob_adoption,frontier_model$fittedvalues[,1],xlab="real value",ylab="ICAR estimation")
plot(regions[,"prop"],reset=F)
plot(frontier_as_sf(frontier_model),add=T,col="green",lwd=2)

```


